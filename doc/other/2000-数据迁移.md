好的！根据你提供的信息，用户的查询语句是一个完整的 **Elasticsearch 查询 JSON**（可能包含嵌套的 `bool`、`filter`、`must` 等结构），并且其中已经包含了时间范围过滤。我们不能简单地“提取时间段”，而是需要在每个子任务中 **保留原始查询结构，并注入对应的时间段条件**。

---

## ✅ 新版任务切分逻辑（支持复杂用户查询 + 时间段注入）

我们将任务拆分为以下 **5 个步骤**：

---

### **1️⃣ 获取索引列表**

- 用户输入索引匹配规则：如 `xxx-*`
- 向源集群发起请求，获取所有匹配该规则的索引名列表
    - 示例：`['xxx-2025-06-01', 'xxx-2025-06-02', ..., 'xxx-2025-06-20']`

---

### **2️⃣ 解析时间范围与粒度**

- 用户选择迁移粒度（如每天、每小时、每 N 小时）
- 用户可能指定了整体迁移的开始和结束时间

> 如果未指定，则根据索引名称或数据时间自动推断最小最大时间

- 根据粒度将整个时间范围划分为多个时间段
    - 示例（按每 6 小时）：
      ```
      [2025-06-01T00:00, 2025-06-01T06:00)
      [2025-06-01T06:00, 2025-06-01T12:00)
      ...
      ```

---

### **3️⃣ 解析用户原始查询条件**

- 用户提交一个完整的 ES 查询 JSON（例如上面那个带有 filter 和 range 的结构）
- 提取其中的 **时间字段名**（如 `@timestamp` 或 `log_time`）和 **已有查询结构**
- 检查是否已存在时间范围过滤，若没有则添加；若有则替换时间区间

---

### **4️⃣ 组合索引 + 时间段 + 注入时间条件到查询语句**

- 遍历所有索引 × 所有时间段组合
- 对每一个组合：
    - 复制用户的原始查询 JSON
    - 替换/注入当前时间段的时间范围到查询中（确保使用正确字段名）
    - 生成一个完整的子任务对象，包含：
        - 索引名
        - 当前时间段起止时间
        - 修改后的完整查询语句
        - 迁移策略（异常处理、是否精准一次性等）

> 示例注入后结果：
```json
{
  "query": {
    "bool": {
      "filter": [
        {
          "range": {
            "@timestamp": {
              "gte": "2025-06-01T00:00:00Z",
              "lt": "2025-06-01T06:00:00Z"
            }
          }
        },
        {
          "term": {
            "type": "log"
          }
        }
      ]
    }
  }
}
```

---

### **5️⃣ 写入数据库并建立父子任务关系**

- 将所有子任务批量写入数据库
- 记录父任务元数据（如创建时间、配置参数、状态等）
- 建立父子任务关联关系（如 `parent_task_id`）

---

## ✅ 总结：新版任务拆分五步走

| 步骤 | 内容 |
|------|------|
| 1️⃣ | 获取匹配索引列表 |
| 2️⃣ | 解析时间范围与粒度，划分时间段 |
| 3️⃣ | 解析用户原始查询语句，提取时间字段名 |
| 4️⃣ | 对每个索引+时间段组合，注入对应时间条件生成完整查询语句 |
| 5️⃣ | 批量写入数据库，建立父子任务关系 |

---

### 💡 补充建议

- 在后端服务中，可封装一个工具方法用于安全地替换查询中的时间范围（避免破坏原有结构）
- 若用户查询中不包含时间条件，可在合适位置插入一个新的 `range` 条件
- 可设计一个“查询模板引擎”来动态注入时间变量（如用占位符 `{start_time}`、`{end_time}`）

---

如果你需要我帮你写这个“注入时间范围”的函数代码（Node.js / Python / Java），也可以告诉我！